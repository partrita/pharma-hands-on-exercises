---
title: "미니 프로젝트 1 - 데이터셋 읽기 및 탐색"
author: "Mike K Smith"
date: "2023년 8월 2일"
output: html_document
---

## 목표:

-   ADSL xpt 데이터셋 읽기
-   유효성 모집단 부분집합 만들기
-   데이터 정렬
-   인구 통계 목록 보기

## 이 문서 사용 방법:

이 문서에는 코드 청크(일반적으로 밝은 회색 배경)와 텍스트가 있습니다. 이는 "Rmarkdown" 문서의 예입니다. 문서 내에서 코드를 작성하고 실행할 수 있으며 결과는 각 코드 청크 아래에 표시됩니다. 텍스트에 작성된 지침을 따르고 코드 청크를 수정하고 실행하여 지시된 대로 출력을 생성해야 합니다.

## 데이터 출처

이 프로젝트에서는 익명화된 CDISC 데이터셋을 사용하며, 다음 위치에서 찾을 수 있습니다: <https://github.com/phuse-org/phuse-scripts/tree/master/data/adam/cdisc>

## R 객체 및 함수

R 내에서는 일반적으로 데이터, 벡터, 목록 등 다양한 유형의 객체를 사용한 다음 함수를 적용합니다. 함수는 `<함수_이름>(<인수1>=   , <인수2> = )` 구성을 갖습니다. 함수를 사용할 때 인수 이름을 반드시 사용할 필요는 없으며 대신 위치별로 인수를 암시적으로 참조할 수 있습니다. 예를 들어 `myFunction(foo, 1, "bar")`는 R 객체 `foo`를 인수 1의 값으로 전달하고, 인수 2는 값 `1`을, 인수 3은 문자 값 `"bar"`를 갖습니다. R을 배우는 동안에는 함수에 인수가 하나만 있는 경우를 제외하고 함수에서 인수를 명시적으로 명명하고 사용하는 것이 좋습니다. RStudio IDE의 탭 완성 기능을 사용하여 함수 호출 인수를 완성하는 데 도움을 받을 수 있습니다. 함수의 인수를 보려면 콘솔에 `?<함수이름>`을 입력하십시오.

## 미니 프로젝트 시작

1.  다음 단계에서는 `tidyverse`, `rio`, `skimr` 및 `htmlTable` 패키지를 로드합니다. 패키지의 함수와 내용을 사용하기 전에 패키지를 로드해야 하며 프로그램/스크립트 시작 부분에 수행하는 것이 가장 좋습니다. 코드 청크 오른쪽의 녹색 화살표를 클릭하여 아래 청크를 실행합니다.

```{r setup}
library(tidyverse)
library(rio)
library(skimr)
library(htmlTable)
```

2.  R에서 데이터를 읽는 방법과 패키지는 여러 가지가 있습니다. 예를 들어 `haven` 패키지에는 \*.xpt 파일에서 R 데이터 객체를 변환할 수 있는 read_xpt() 함수가 있습니다. `readr` 패키지는 쉼표로 구분된 값(CSV) 및 탭으로 구분된 값(TSV)과 같은 구분된 파일에서 사각형 데이터를 빠르고 쉽게 읽을 수 있는 방법을 제공합니다. `readxl` 패키지를 사용하면 Excel에서 R로 데이터를 쉽게 가져올 수 있습니다. 패키지에 관계없이 데이터를 읽을 수 있는 함수는 일반적으로 첫 번째 인수가 데이터 경로이지만 새 패키지나 함수를 사용하기 전에 항상 설명서를 읽는 것이 중요합니다.

미니 프로젝트에서는 `rio` 패키지를 사용하여 데이터를 읽습니다. `rio`는 가져오기 및 내보내기를 위한 다양한 파일 형식을 지원하며 간소화된 데이터 가져오기를 제공합니다. 특히 `rio`는 파일 이름의 파일 확장자를 사용하여 파일 유형을 결정하므로 `rio`를 사용하여 데이터 파일을 읽기 위해 기억해야 하는 유일한 함수는 import()입니다.

GitHub 위치(`https://github.com/phuse-org/phuse-scripts/raw/master/data/adam/cdisc/adsl.xpt`)에서 adsl 데이터를 읽고 할당 연산자 `<-`를 사용하여 R의 객체에 할당합니다. URL 위치가 `" "`로 묶인 문자열인지 확인하십시오. 아래 코드의 "" 인수 내에 다운로드 경로 위치를 붙여넣은 다음 녹색 화살표를 사용하여 청크를 실행합니다.

```{r read_adsl_data}

adsl <- import(file =  "")

```

3.  R 객체 `adsl`의 처음 10개 행을 보려면 데이터셋 이름을 입력하기만 하면 됩니다. 아래 청크에 `adsl`을 입력하고 녹색 화살표를 사용하여 실행합니다.

```{r view_adsl_object}

```

`adsl` 데이터 객체에는 254개의 행과 48개의 열이 있습니다.

4.  다음으로 R 함수 `sapply`를 사용하여 데이터셋의 각 열 유형을 확인합니다. 이렇게 하면 열이 문자, 숫자, 정수, 배정도, 요인 등인지 알 수 있습니다. `class` 함수는 R 객체의 유형을 알려줍니다.

`sapply` 함수는 동일한 함수 `class`를 데이터의 각 열에 적용하고 벡터로 데이터 유형을 반환합니다.

```{r view_adsl_data_types}

sapply(X = adsl, FUN = class)

```

5.  개별 변수의 유형(또는 `class`)을 확인(또는 테스트)하려면 `is.numeric`, `is.character` 등의 함수를 사용할 수 있습니다. 데이터 객체의 개별 열을 참조하려면 `<객체>$<변수>` 구성을 사용할 수 있습니다.

[**R은 대소문자를 구분합니다! R 객체, 변수 또는 데이터셋의 이름을 입력할 때 대소문자가 표시된 것과 일치하는지 확인하십시오.**]{.smallcaps} 따라서 "AGE"는 "age" 또는 "Age"와 같지 않습니다. 아래 변수 이름은 대문자로 표시됩니다.

`AGE` 변수가 숫자인지, `RACE`가 문자인지 확인해 보겠습니다. 이러한 함수는

```{r check_variable_types}

is.numeric( )

is.character( )

```

6.  R로 작업을 수행하는 데 도움이 되는 R 패키지는 *많이* 있습니다. `skimr` 패키지는 데이터셋에 대한 유용한 요약 정보(행 수, 열 수, 누락된 데이터, 열 유형, 데이터 열의 값 분포)를 빠르게 표시하는 패키지 중 하나입니다.

```{r skimr}

skim(data = adsl)

```

참고: 출력의 일부로 경고 메시지가 표시될 수 있습니다.

일부 열에 누락된 값이 있는 경우 이러한 경고 메시지를 사용하여 데이터 형식이 올바른지, 열이 올바르게 구문 분석되었는지 확인할 수 있습니다. 예를 들어 코딩된 값이 0, 1인 열은 숫자로 읽힐 수 있습니다. 이것이 우리가 원하는 방식입니까, 아니면 요인으로 해석하시겠습니까?

7.  이제 유효성 분석 모집단에 대한 새 데이터 객체 `adsl_eff`를 만듭니다. 변수 `EFFFL`의 값이 `Y`인 `adsl` 데이터 객체를 필터링해야 합니다. R에서 동등성을 테스트하려면 이중 등호 `==`를 사용해야 합니다. 아래 `filter` 함수의 첫 번째 인수(`.data=`)로 `adsl` 객체를 입력합니다.

```{r create_adsl_eff}

adsl_eff <- filter(.data = , EFFFL == 'Y')

adsl_eff

```

`EFFFL == 'Y'`인 데이터를 필터링한 후 이제 234개의 행과 48개의 열이 있습니다.

다시 말하지만 R은 대소문자를 구분합니다. SAS 데이터셋의 대부분의 변수 이름은 대문자이므로 변수 이름이 대문자인지 확인해야 합니다(예: `EFFFL`이지 `Efffl` 등이 아님). 또한 값이 문자이므로 동등한 값의 대소문자가 예상 결과와 일치하는지 확인해야 합니다(예: `y` 또는 `Yes`가 아닌 `Y`이고 따옴표 `" "`로 묶여 있음).

8.  `USUBJID` 변수를 기준으로 `adsl_eff` 데이터 객체를 정렬합니다. 첫 번째 인수 뒤에 정렬하려는 변수를 입력합니다.

```{r arrange_adsl_eff}

sort_adsl_eff <- arrange(.data = adsl_eff, )

```

R의 `tidyverse` 패키지에는 여러 단계를 결합할 수 있는 파이프 연산자 `%>%`가 있습니다. 파이프는 이전 단계의 출력 객체를 다음 함수의 첫 번째 인수에 사용할 값으로 전달합니다. 따라서 이전 단계를 다음 데이터 파이프라인으로 결합합니다.

```{r using_pipe}

sort_adsl_eff <- adsl %>%

  filter(EFFFL == "Y") %>%

  arrange(USUBJID)

```

`%>%` 연산자를 사용할 때 "...그런 다음..."으로 읽습니다. 따라서 위의 파이프라인은 "(**adsl_eff**라는 객체를 만듭니다)는 (객체로 시작하여) **adsl** *...그런 다음...* **필터**(`EFFFL`이 "Y"인 경우) *...그런 다음...* **정렬**(`USUBJID` 기준)으로 **할당됩니다**." 파이프 연산자를 사용하면 중간 객체가 R에서 명명된 객체로 유지할 가치가 없는 단계를 결합할 수 있습니다. 파이프 연산자를 사용할 때 더 이상 다음 함수의 `.data =` 인수를 명시적으로 사용하지 않는다는 점에 유의하십시오. 이는 `%>%`가 기본적으로 이전 객체를 첫 번째 인수의 값으로 전달하기 때문입니다.

9.  다음을 시도하여 `EFFFL=='Y'`인 관측치가 234개 있음을 보여주는 `adsl_eff`의 `skim` 요약을 확인하십시오.

```{r skim_adsl_eff}

skim( )

```

10. `TRT01A`, `USUBJID` 변수를 기준으로 `adsl_eff` 데이터를 정렬하고 새 데이터셋 `adsl_eff_srt`를 만듭니다. 이전 코드(힌트: `arrange( )`)를 사용하여 데이터를 정렬할 수 있습니다.

```{r sort_adsl_eff}

```

11. `select` 함수는 데이터 객체의 지정된 열만 선택합니다. adsl_saf_srt 데이터 객체에서 다음 변수만 선택합니다: `USUBJID, AGE, AGEU, SEX, RACE, ETHNIC, TRT01A`. 이 변수 목록을 복사하여 `select` 문에 붙여넣습니다.

```{r adsl_saf_srt_select}

adsl_eff_srt <- adsl_eff_srt %>%

  select( )

adsl_eff_srt

```

이제 `adsl_eff_srt` 데이터 객체에는 여전히 234개의 행이 있지만 열은 7개뿐입니다.

12. 일반적으로 인구 통계 목록은 데이터셋의 변수 이름을 직접 사용하지 않습니다. 따라서 열 이름을 변경하는 단계를 추가합니다. `names()` 함수는 문자/이름 벡터를 전달하여 지정된 객체의 이름을 할당합니다. 컬렉션 함수 `c( )`와 쉼표로 구분된 이름 목록을 사용하여 벡터를 만듭니다. 아래 코드를 사용하여 `adsl_saf_srt` 함수의 변수 이름을 `"Subject ID","Age","AgeUnits","Sex","Race","Ethnicity","Treatment"`로 변경합니다.

```{r rename_adsl_eff_srt}

names(x = adsl_eff_srt) <- c( )

```

13. 이제 데이터 목록을 생성할 수 있습니다. R에는 테이블을 표시하거나 목록을 인쇄할 수 있는 여러 패키지가 있습니다. 이와 같은 Rmarkdown 문서에서는 출력을 간단히 인쇄하면 데이터의 멋진 HTML 표현이 만들어집니다. Rmarkdown 문서에 표시하려면 아래에 데이터 객체 이름을 추가하십시오.

```{r display_adsl_eff_srt}

print( )

```

그러나 나중에 사용하기 위해 이 출력을 저장하려면 이러한 패키지 중 하나를 사용하여 데이터 목록이 포함된 출력 파일을 만들어야 합니다. 각 테이블 패키지에는 장단점이 있지만 지금은 `htmlTable` 패키지를 사용하여 HTML 목록을 표시해 보겠습니다. `htmlTable` 출력을 표시하려면 아래에 데이터 객체 이름을 추가하십시오. 여기의 추가 인수는 테이블 형식이 보기 좋게 만들어지도록 합니다. 이는 이 첫 번째 프로젝트의 범위를 벗어납니다. `align = "l"` 인수를 변경하고 `align = "c"` 또는 `align = "r"` 옵션을 시도하여 열 내용을 각각 왼쪽, 가운데 또는 오른쪽으로 정렬하십시오.

```{r create_listing_with_htmlTable}

htmlTable(x =  adsl_eff_srt,

          align = "l",

          rnames=FALSE,

          css.cell = "padding-left: .5em; padding-right: .2em;")

```

14. 다음으로 이 .rmd 파일을 바탕 화면에 저장한 다음 파일 상단의 "Knit" 버튼을 클릭하여 이 문서의 HTML 버전을 렌더링합니다.
