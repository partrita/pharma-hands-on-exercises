---
title: "미니 프로젝트 8 - 반복을 통한 함수 적용"
author: "Mike K Smith"
date: "2023년 3월 6일"
output: html_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(rio)

adsl_saf <- import("https://github.com/phuse-org/phuse-scripts/raw/master/data/adam/cdisc/adsl.xpt") %>%
    filter(SAFFL == "Y")
```

## 개요

이 미니 프로젝트에서는 R을 사용하여 데이터에 함수를 적용하고, 행, 열 및 데이터 하위 집합을 반복하는 방법을 살펴봅니다.

R에서 루프를 작성하는 방법을 살펴보겠지만, R에서 루프가 항상 최상의 솔루션은 아닌 이유에 대해서도 논의합니다.

기본 R `apply` 함수를 살펴봅니다. 이러한 함수는 매우 유용하지만 각 함수는 특정 유형의 입력 객체를 사용한 다음 특정 구조의 출력 객체를 반환하며 종종 다른 인수를 갖습니다.

열 또는 행 내용에 걸쳐 함수를 반복하고 영향을 받을 열 또는 행을 선택할 수 있는 몇 가지 `{tidyverse}` 함수를 살펴봅니다. 또한 `{purrr}` 패키지와 목록의 요소에 걸쳐 작업을 반복하고 데이터를 목록 형식으로 분해하는 데 사용할 수 있는 방법을 살펴봅니다.

마지막으로 필요한 경우 항목 모음에 대한 반복 함수를 훨씬 빠르게 만들기 위해 여러 프로세서에 작업을 분할하는 다양한 옵션에 대해 간략하게 논의합니다.

## SAS에서는 루프를 사용하지만 R에서는 그렇지 않습니다...

SAS에서는 일반적으로 DATA 단계를 사용하여 데이터 값에 대한 계산을 수행합니다. SAS는 ***행별***로 데이터 열 전체의 값을 확인하여 데이터를 처리합니다. SAS에서는 열 전체에 함수를 적용하고 루프를 작성하여 행을 반복하거나 순환하는 코드를 작성하는 것이 자연스럽습니다.

S-Plus를 사용한 S 언어 구현에서는 ***수년 전***에 루프 작업이 결국 S-Plus를 충돌시킬 수 있는 메모리 누수가 있었습니다. 이러한 이유로 개발자들은 S 코드에서 루프 사용을 피했으며 이러한 루프 공포증은 R 코드 개발에도 이어졌습니다. 그러나 루프와 루프가 종종 구현되는 방식에는 R에서 효율성을 떨어뜨리는 몇 가지 다른 속성이 있습니다. 이에 대해서는 나중에 살펴보겠습니다...

R은 값, 배열, 행렬, 목록 및 데이터 프레임(본질적으로 모든 벡터가 동일한 길이를 갖는 벡터 목록)의 벡터를 처리합니다. R은 벡터 전체에 대한 계산이나 작업을 매우 쉽고 빠르게 수행할 수 있도록 작성되었습니다.

예를 들어 `adsl_saf` 열의 누락되지 않은 값 수를 계산하려면 먼저 단일 열에 대해 이 작업을 수행하는 방법을 알아낼 수 있습니다.

```{r}
adsl_saf %>%
  select(SUBJID) %>%
  summarise(nonmiss = sum(!is.na(SUBJID)))
```

이 예에서 R은 SUBJID 변수의 값이 누락되었는지 (누락되지 않았는지) 평가하여 `is.na` 함수를 통해 모든 관찰에 대해 동시에 `TRUE` 또는 `FALSE`를 생성합니다. 그런 다음 `TRUE` = 1이고 `FALSE` = 0인 해당 값의 합계를 구합니다. 이렇게 하면 열의 누락되지 않은 값 수가 제공됩니다.

R은 열과 매우 효율적으로 작동하도록 작성되었으며 `is.na` 및 `sum`과 같은 함수는 전체 입력 벡터에 걸쳐 필요한 값을 매우 빠르게 계산합니다. 열의 모든 값에 대해 `if(!is.na(SUBJID), TRUE, FALSE)`를 작성하고 반복할 필요가 없었습니다. R은 `is.na` 함수를 벡터의 모든 값에 적용하고 입력 벡터의 각 값에 대해 `TRUE` 또는 `FALSE` 벡터를 반환해야 한다는 것을 알고 있습니다.

## 루프를 사용해야 하는 경우...

`adsl_saf`의 모든 열에 대해 이 작업을 수행하려면 R에 이를 수행하도록 지시하는 방법을 알아내야 합니다. `adsl_saf`의 모든 변수 이름을 순환하는 루프를 만든 다음 위와 동일한 작업을 수행하는 것을 자연스럽게 생각할 수 있습니다.

1.  이렇게 하려면 먼저 `adsl_saf` 데이터셋의 열 이름이 필요합니다. `names` 함수를 사용하여 이를 얻습니다.

    `varNames <- names(adsl_saf)`

2.  그런 다음 계산된 값을 포함할 `counts`라는 벡터를 설정합니다. 나중에 살펴볼 효율성상의 이유로 값을 넣기 전에 결과 객체를 올바른 길이로 준비하는 것이 좋습니다. 결과 값은 정수이며 벡터는 데이터셋의 열 수와 동일한 길이를 갖습니다.

    `counts <- vector("integer", length(varNames))`

3.  다음으로 루프를 구성합니다. R에는 `for` 루프와 `while` 루프가 있습니다. `for` 루프는 무한 루프에 빠지는 경향이 적으므로 여기서는 `for` 루프를 선호합니다. `for` 루프의 상한 범위에 특정 숫자를 지정하는 대신 `varNames` 벡터의 길이를 사용합니다. 이렇게 하면 다른 수의 열이 있는 데이터셋을 전달해도 코드가 계속 작동합니다.

    `for(i in 1:length(varNames)){`

    `}`

4.  루프의 `{ }` 내에는 각 반복에서 실행할 코드를 넣습니다. counts 벡터의 요소 `i`를 할당합니다. `varNames` 벡터의 i번째 요소를 가리키고 이를 사용하여 `[[` 연산자를 사용하여 작업할 `adsl_saf`의 열을 선택합니다. 그런 다음 `!is.na` 논리 비교를 사용하여 열의 값이 누락되었는지 확인합니다. 이렇게 하면 각 값에 대해 `TRUE` 또는 `FALSE` 결과가 제공됩니다. `sum` 함수를 사용하면 `FALSE`에 대해 0으로, `TRUE`에 대해 1로 효과적으로 처리되므로 합계는 누락되지 않은 값의 수를 계산합니다. `!is.na`와 `sum`은 이전에 보았듯이 단일 작업으로 전체 벡터에 대해 작동합니다.

        counts[i] <- sum( !is.na( adsl_saf[[varNames[i]]] ) )

5.  루프가 끝나면 `counts`의 `i` 값은 각 열의 누락되지 않은 값 수로 채워져야 합니다. (함수에서와 마찬가지로) 루프에서 항목을 반환하지 않으면 나중에 사용할 수 있도록 저장되지 않습니다.

6.  `varNames`를 사용하여 벡터 요소의 이름을 지정합니다.

    `names(counts) <- varNames`

이 모든 것을 종합하면 아래 코드 청크가 됩니다.

```{r}
varNames <- names(adsl_saf)
counts <- vector("integer", length(varNames))
for(i in 1:length(varNames)){
  counts[i] <- sum(!is.na(adsl_saf[[varNames[i]]]))
}
names(counts) <- varNames
head(counts)
```

이것이 작동하지만 코드가 약간 투박합니다. SAS를 배우고 반복을 처리하는 "루프 방식"에 익숙해진 동료들에게서 이런 코드(또는 변형)를 ***항상*** 봅니다.

이렇게 하면 데이터셋이 아닌 ***명명된 요소의 벡터***가 생성되므로 원하는 요소를 추출하기가 쉽지 않습니다. `{tidyverse}` `select` 문을 시도하면 오류가 발생합니다.

```{r}
counts %>%
  select(STUDYID)
```

위 오류에서 정확히 무엇이 문제인지 즉시 명확하지 않습니다. `counts`가 데이터 프레임이라고 가정하고(따라서 두 차원을 가짐) 변수 이름으로 부분집합을 만듭니다.

```{r}
counts[,"STUDYID"]
```

다시 말하지만 오류가 약간 모호합니다. 그리고 ***당신***은 이것이 명명된 벡터라는 것을 기억할 수 있지만 코드를 확인하는 다른 사람은 이것을 놓칠 가능성이 매우 높습니다.

```{r}
counts["STUDYID"]
```

루프 길이가 *사전에* 알려지지 않은 상황에서는 목록에 항목을 추가하여 루프로 출력을 늘리고 싶을 수 있습니다.

```{r}
counts <- NULL
for(i in 1:length(names(adsl_saf))){
  counts <- c(counts, sum(!is.na(adsl_saf[i,])))
}
counts
```

***루프 내에서 항목을 `c(.)`하여 출력 객체를 "늘리지 마십시오".***

여기서 문제는 이러한 작업 방식이 2차 순서를 가지므로 요소가 3배 많은 루프는 9배(3의 제곱) 더 오래 걸린다는 것입니다. R은 객체가 미리 얼마나 커야 하는지 알지 못하므로 메모리의 객체를 루프로 ***복사***하여 효과적으로 n개의 객체 버전을 만듭니다. 이를 피하려면 항상 출력 객체를 올바른 차원으로 ***먼저*** 설정한 다음 값으로 채우는 것이 가장 좋습니다. 이렇게 하면 R은 기존 값(0 또는 NULL인 경우에도)을 새 값으로 효과적으로 덮어씁니다.

## apply 계열

기본 R에서 `apply` 계열은 입력을 받아 각 요소에 동일한 ***함수***를 적용하여 출력을 만듭니다. `apply` 함수는 값의 ***배열***을 가져와 하나 이상의 `MARGIN`에 걸쳐 함수를 적용합니다.

***누락된 값 찾기...***를 해봅시다.

```{r}
randomNumberArray <- array(rnorm(70), dim = c(7, 10))
## 임의로 숫자 하나를 누락시킵니다.
randomNumberArray[sample(1:7,1), sample(1:10,1)] <- NA

nonMissing <- function(vector){
  sum(!is.na(vector))
}

round(randomNumberArray,2)
```

행 전체에 `nonMissing` 함수를 적용하려면 MARGIN = 1을 지정합니다.

```{r}
apply(randomNumberArray, MARGIN = 1, FUN = nonMissing)
## 누락된 값이 있는 곳을 제외하고 숫자 10을 포함하는 크기 7의 벡터를 반환합니다.
```

열 전체에 nonMissing 함수를 적용하려면 MARGIN = 2를 지정합니다.

```{r}
apply(randomNumberArray, MARGIN = 2, FUN = nonMissing)
## 누락된 값이 있는 곳을 제외하고 숫자 7을 포함하는 크기 10의 벡터를 반환합니다.
```

이 함수를 데이터셋의 열에 적용하려면 목록의 요소에 함수를 적용하는 유사한 함수 `lapply`가 필요합니다(`lapply` == ***l***ist ***apply***). 데이터 프레임은 동일한 길이의 벡터로 구성된 명명된 목록임을 상기하십시오.

```{r}
lapply(adsl_saf, FUN = nonMissing) %>%
  head()
```

이것은 좋지만 우리가 얻는 것은 목록입니다. 이 목록을 벡터로 변환하려면 `sapply` = ***s***implify ***apply***이므로 `lapply` 대신 `sapply`를 사용할 수 있습니다.

```{r}
sapply(adsl_saf, FUN = nonMissing) %>%
  head()
```

요인 수준 내에서 함수를 적용하려면 `tapply`를 사용할 수 있습니다.

```{r}
tapply(adsl_saf$AGE, INDEX = adsl_saf$TRT01A, FUN = nonMissing)
```

그러나 `tapply`는 벡터와 INDEX 변수에 함수를 적용하기 때문에 한 번에 하나의 변수에만 적용됩니다. `adsl_saf`의 모든 열에 `tapply`를 적용하려면 `tapply`를 `apply`하고 어떤 `MARGIN`에서 작업해야 하는지 기억하고 적용해야 하는 `FUN` 함수를 함수로 표현해야 한다는 것을 알아내야 합니다. 그런 다음 출력을 사용하려면 명명된 배열의 요소를 참조하는 방법을 알아내야 합니다... 쉽지 않습니다.

```{r}
apply(adsl_saf, MARGIN = 2,
      FUN = function(x)tapply(x, INDEX = adsl_saf$TRT01A, FUN = nonMissing)) %>%
  head()
```

그리고 예, `apply` 함수의 전체 ***계열***이 있습니다.

`apply`, `lapply`, `sapply`, `tapply,` `mapply`, `rapply`, ...

이러한 각 함수가 정확히 무엇을 하는지, 입력으로 무엇을 예상하는지, 출력으로 무엇을 생성할 가능성이 있는지, 각 함수의 인수가 무엇을 하는지 기억하기 어렵습니다.

## 깔끔한 반복

### `across`를 사용한 열별 작업.

이를 해결하기 위해 `{tidyverse}`는 데이터셋의 여러 열이나 행에 걸쳐 동일한 작업을 수행하는 더 쉬운 방법을 고안했습니다. 또한 함수를 적용하고 예측 가능한 결과를 다시 얻을 수 있도록 하는 확장 기능도 있습니다. 이전 미니 프로젝트에서는 그룹당 개수 요약을 다시 얻기 위해 `summarise` 함수에 의존했습니다.

```{r}
adsl_saf %>%
  group_by(SEX) %>%
  summarise(n = n())
```

`summarise`는 열 전체에서도 작동하지만 함수를 적용할 ***어떤*** 열을 함수에 알려야 합니다. 이를 위해 `across` 함수를 사용합니다. 이 함수는 두 가지 주요 인수, 즉 작업할 열을 정의하는 `.cols`와 식별된 각 열에 적용할 함수를 정의하는 `.fns`를 사용합니다.

```{r}
adsl_saf %>%
  summarise(across(.cols = everything(), .fns = nonMissing))

```

이 작업에서 얻는 것은 또 다른 `tibble` 데이터 세트입니다. 이는 `{dplyr}` 데이터 파이프라인에서 이 데이터를 계속해서 매우 쉽게 처리할 수 있기 때문에 편리합니다.

여기서 `.cols = everything()` 인수를 사용하는 것은 `{tidyselect}` 패키지 내의 멋진 함수 세트에 의존하는 것입니다. 이를 통해 요약할 열을 매우 정확하게 지정할 수 있습니다. `.cols`에 대한 옵션에는 `starts_with`, `ends_with`, `contains`, `all_of`, `any_of`, `where(is.numeric)`, `where(is.character)` 등이 있습니다. 또는 위치별로 열을 지정할 수 있습니다(예: 2:9). 또는 작업할 열의 이름을 간단히 지정할 수 있습니다. 아래 코드 청크에서는 열 이름 벡터와 일치시키려고 시도한 다음 지정된 이름과 일치하는 모든 열에 함수를 적용하는 `any_of` 옵션을 사용합니다.

```{r}
adsl_saf %>%
  summarise(across(.cols = any_of(c("AGE","SEX", "RACE","ETHNIC")),
                   .fns = nonMissing)
            )

```

대안은 `all_of`일 수 있지만 세트에서 열이 누락되면 작업이 중지됩니다.

```{r}
adsl_saf %>%
  summarise(across(.cols = all_of(c("AGE","SEX", "RACE","ETHNIC","MIKE")),
                   .fns = nonMissing)
            )

```

`{tidyselect}`의 장점은 매우 자명한 구문을 사용하며 데이터셋의 열 위치에 의존하지 않는다는 것입니다. 따라서 다른 입력 데이터에 대해 매우 강력하게 구성할 수 있습니다. 위 예에서 `ETHNIC` 변수가 누락된 경우 코드는 계속 실행되지만 `AGE, SEX, RACE`에 대한 결과만 보고합니다.

`where(is.numeric)`를 사용하면 숫자 변수만 처리할 수 있습니다. 이는 인쇄 목적에 유용할 수 있습니다. 예를 들어 ***모든*** 숫자 값을 소수점 이하 두 자리로 반올림하고 싶을 수 있습니다. 그러나 아래 예에서는 모든 숫자 열의 중앙값을 반환합니다.

```{r}
adsl_saf %>%
  summarise(across(.cols = where(is.numeric),
                   .fns = median)
            )
```

`group_by` 작업을 통합할 수도 있습니다.

```{r}
adsl_saf %>%
  group_by(TRT01A, TRT01AN) %>%
  summarise(across(.cols = where(is.numeric),
                   .fns = median)
            )

```

`summarise` 대신 `mutate` 동사를 사용하여 유사한 함수를 수행할 수도 있습니다. 예를 들어 모든 문자 열이 대문자로 표시되도록 하려면 다음과 같이 합니다.

```{r}
adsl_saf %>%
  mutate(across(.cols = where(is.character),
                   .fns = toupper)
            )
```

### `rowwise`를 사용한 행별 작업.

마찬가지로 `rowwise` 작업을 사용하여 데이터셋의 행 전체에 작업을 수행하도록 R에 지시할 수 있습니다. `rowwise`는 본질적으로 특별한 종류의 `group_by` 작업입니다. 식별자 변수를 사용하여 데이터셋의 한 줄을 식별해야 합니다. 그런 다음 이전과 같이 `mutate` 및 `summarise`를 사용하여 `rowwise`에 정의된 각 행에 대해 열 전체에서 작업할 수 있습니다. 열별 작업의 `across`에 해당하는 것은 `c_across`입니다. 열별 작업의 `across`는 등호 ***왼쪽***에 있고 일반적으로 함수가 연결되어 있는 반면, `c_across`는 등호 ***오른쪽***에 있고 종종 함수 연산자 ***내에*** 있으며 열***만*** 선택합니다.

```{r}
adsl_saf %>%
  rowwise(SUBJID) %>%
  summarise(missingData = sum(
                               is.na(
                                      c_across(
                                                where(is.numeric)
                                                )
                                      )
                               )
            )

```

여기서는 각 피험자의 데이터 행에 대한 ***누락된*** 항목 수를 표시하도록 함수를 뒤집었습니다. 이는 데이터 검토 상황에서 매우 유용할 수 있습니다.

## `map`을 사용하여 `{purrr}` 함수 만들기.

위에서 설명한 열별 및 행별 작업을 사용하면 루프를 작성하지 않고도 많은 작업을 수행할 수 있습니다. 그러나 `apply` 계열 함수와 유사하지만 모든 다른 입력, 출력 및 인수 옵션을 기억할 필요 없이 사용할 수 있는 것이 유용할 경우가 있습니다.

`{purrr}` 패키지는 `map` 계열 함수를 사용하여 이를 해결하려고 합니다. 이러한 함수는 모두 동일한 기본 구조와 인수를 갖습니다. `map` 함수는 입력으로 ***목록***을 사용하며 사용자는 목록의 각 요소에 대해 작동할 함수를 제공해야 합니다. 그러나 데이터를 목록으로 나누는 것은 매우 쉽습니다.

```{r}
adsl_saf %>%
  split(f = .$SUBJID) %>%
  head(2)

```

그런 다음 `map` 함수를 사용하여 해당 데이터 세트에 모든 함수를 적용할 수 있습니다.

```{r}
library(skimr)
adsl_saf %>%
  split(f = .$TRT01A) %>%
  head(2) %>%
  purrr::map(.f = skimr::skim)
```

부작용(예: 그래프 그리기 또는 파일에 무언가 쓰기)을 위해 목록 항목에 함수를 적용하려면 해당하는 `walk` 함수가 있습니다.

`map` 함수에는 출력 객체의 유형(또는 출력이 가져야 하는 열 속성의 유형)을 지정하는 확장 기능이 있습니다. 또한 두 목록을 동시에 작업하여 항목을 처리할 수 있도록 하는 확장 기능도 있습니다. 예를 들어 입력 1의 첫 번째 요소를 사용하여 일부 값을 계산하고 입력 2의 첫 번째 요소에서 설정을 사용할 수 있습니다.

### 속도 향상, 병렬화

함수로 작업하고 일부 속성으로 정의된 목록으로 데이터를 분할하는 것의 장점은 병렬 처리를 사용하여 긴 작업을 훨씬 더 빠르게 할 수 있다는 것입니다. 루프는 (기본적으로) 하나의 프로세서에서 작동합니다. `apply` 계열 함수는 하나의 프로세서에서 작동합니다. `{dplyr}` 동사는 하나의 프로세서에서 작동합니다. 그러나 R로 작업을 더 빠르게 만드는 방법은 항상 있습니다.

`{multidyplr}` 패키지를 사용하면 프로세서 클러스터를 설정한 다음 `group_by` 그룹 전체에서 `{dplyr}` 동사를 사용할 수 있습니다.

<https://multidplyr.tidyverse.org/articles/multidplyr.html>

`{furrr}` 패키지는 `{purrr}`와 유사한 함수 유사체를 사용하여 여러 프로세서에 작업을 분할합니다.

<https://furrr.futureverse.org/>

`{foreach}` 패키지는 프로세서 클러스터를 설정하고 `foreach(...) %do%` 구문을 사용하여 작업을 분할합니다.

<https://cran.r-project.org/web/packages/foreach/vignettes/foreach.html>

이러한 각 패키지를 사용하는 것은 이 미니 프로젝트의 범위를 약간 벗어나지만 대규모 데이터 처리를 수행해야 하는 경우 사용할 수 있다는 것을 아는 것이 좋습니다. 이제 데이터를 목록 객체로 분할하고 해당 목록의 각 요소에 함수를 적용하는 방법을 알게 되었습니다.

## 도전 과제

미니 프로젝트 7에서 개발한 `adsl_counts` 함수를 여기 `adsl_saf` 데이터에 적용하여 각 `RACE` 값에 대해 `TRT01A`별 `SEX` 개수를 표시합니다.
