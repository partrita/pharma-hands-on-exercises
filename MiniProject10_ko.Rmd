---
title: "미니 프로젝트 10 - 디버깅"
author: "Mike K Smith"
date: "2023년 9월 3일"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 디버깅 전략

1.  껐다가 다시 켜기 - 환경 비우기
2.  환경 이해하기 - 전역 및 지역
    1.  환경에서 항목 보기
3.  `debugonce()`, `browser()` 및 RStudio IDE 중단점.
4.  `traceback()`, `options(error = recover)`,

막히면 이 비디오를 검토하십시오:
<https://www.youtube.com/watch?v=vgYS-F8opgE>

## 깨끗한 환경은 좋은 것입니다

시간이 지남에 따라 R에 있는 STUFF 컬렉션이 늘어날 것입니다. 문제는 "봄맞이 대청소"를 하고 물건을 정리하지 않으면 결국 R의 객체 컬렉션에 있는 무언가가 현재 작업에 문제를 일으킬 것이라는 점입니다... 오늘 데이터와 생성한 벡터로만 작업하고 있다고 ***생각***할 수 있지만, 문제가 발생하면 이전 세션에 존재했던 동일한 이름의 해당 객체 버전을 선택하고 있을 수 있습니다. 이는 다소 위험합니다.

R 세션을 봄맞이 대청소하는 가장 쉬운 방법은 환경을 비우고 R을 다시 시작하는 것입니다.

![R 전역 환경에 "adsl"이라는 데이터, "ALTmax" 및 "ALTmin"이라는 벡터, "uniqueVal"이라는 함수 등 4개의 객체가 있음](img/MiniProject10_Environment.PNG)

![ "빗자루" 아이콘을 클릭하면 나타나는 팝업 대화 상자가 있는 R 전역 환경](img/MiniProject10_CleaningEnvironment.PNG)

이렇게 하면 환경이 비워지고 "새로" 시작됩니다. 이 작업을 수행하기 전에 유지해야 할 모든 것을 저장하는 것을 잊지 마십시오!!

재현성을 위해 R을 시작하거나 스크립트를 "처음부터 끝까지" 실행하여 출력을 만들 때마다 "깨끗한" 환경으로 시작하는 것이 좋습니다. 이렇게 하면 스크립트를 실행하는 데 필요한 모든 것이 스크립트 내에 포함되고 실행하기 위해 환경에 객체가 있어야 하는 것에 의존하지 않도록 할 수 있습니다.

R 세션을 시작할 때 이 "깨끗한 페이지"로 시작하는 것을 좋아합니다. RStudio IDE의 "전역 옵션"의 일반 탭으로 이동하면 R을 시작할 때 기존 작업 공간(환경)을 다시 로드하지 않고 종료 시 작업 공간을 저장할지 묻지 않는 옵션이 있습니다. 정말 깨끗하고 깔끔하게(그리고 재현 가능하게) 하려면 "복원" 옵션을 선택 취소하고 "저장" 옵션에 대해 "안 함"을 선택해야 합니다. 이렇게 하면 R 세션을 시작할 때마다 완전히 깨끗해집니다. 매번.

![작업 공간에서 객체를 저장하거나 복원하지 않는 전역 옵션(RStudio IDE)](img/MiniProject10_GlobalOptions.PNG)

## 껐다가 다시 켜십시오.

환경을 비우는 "빗자루" 버튼은 많은 도움이 되지만 실제로는 ***모든 것***을 비우지는 않습니다. 제거되지 ***않는*** 몇 가지 항목:

-   `library( )` 호출
-   R `options( )`
-   시스템 환경 설정, 즉 `Sys.setenv( )`
-   `attach( )`를 사용하여 데이터셋 연결

코드가 재현 가능한지 확인하려면 사용하는 모든 라이브러리가 `library()`를 사용하여 참조/호출되는지 확인해야 합니다. 이는 일반적으로 스크립트 상단에서 수행되므로 다른 사람들이 필요한 라이브러리가 설치되어 있는지 확인할 수 있습니다.

스크립트가 재현 가능한지 ***확인***하는 방법은 R을 다시 시작하는 것입니다. RStudio IDE에서는 "세션" 메뉴 또는 바로 가기 키 CTRL+SHIFT+F10을 사용하여 이 작업을 수행할 수 있습니다.

![RStudio 세션 메뉴 또는 바로 가기 키 CTRL+SHIFT+F10에서 R 다시 시작](img/MiniProject10_Restart_R.PNG)

R을 다시 시작하라는 이 조언은 패키지를 설치하기 전(그리고 설치 후!)에도 특히 중요합니다. R 세션 중간에 패키지를 설치하는 것은 고속도로를 달리는 버스의 타이어를 교체하는 것과 같습니다...

R이 "이상하게" 작동하면 세션을 다시 시작하고 다시 시도하는 것이 좋습니다...

## 환경 이해

전역 환경(R의 "환경" 패널에 표시되는 객체 모음)은 R 스크립트 및 R 코드에서 보고 사용할 수 있는 항목 모음입니다. 그러나 다른 환경이 존재하거나 생성될 수 있습니다. 일반적으로 이런 일이 발생하는 곳 중 하나는 함수 내부입니다. 함수에는 자체 환경이 있으므로 함수 호출 내에서 만드는 객체(벡터, 데이터)는 함수 범위 내에서만 정의됩니다.

함수를 작성하고 실행하면 새 객체를 정의하고 사용할 수 있는 ***실행 환경***이 만들어집니다. 그러나 함수가 완료되면 이러한 모든 객체는 삭제됩니다. 이러한 객체의 목적은 함수에서 다시 전달할 최종 결과를 만드는 것***뿐입니다***.

-   ***일반적으로 함수에서 최종 결과 객체만 전달해야 합니다. 함수에서 만든 객체를 전역 환경에 넣지 마십시오.***
-   ***함수 인수를 통해 전달되지 않는 한 함수 내에서 전역 환경 객체를 참조하는 것은 일반적으로 좋지 않은 관행입니다.***
-   ***함수를 사용하는 사람이 호출할 때 환경에 특정 항목이 있어야 한다고 의존해서는 안 됩니다.***
-   ***함수 내에서 옵션을 변경하거나 작업 디렉터리를 설정하는 것은 일반적으로 좋지 않은 관행입니다.***

이를 설명하기 위해 매우 간단한 함수를 만들어 보겠습니다. 시작하기 전에 빗자루 버튼을 사용하여 환경을 비우거나 R을 다시 시작했는지 확인하십시오. 실행하기 전에 `myFunction(2)`의 결과는 무엇입니까?

```{r}
myFunction <- function(x){
  a <- 3
  x + a
}

myFunction(2)
```

이제 이 코드를 사용해 보십시오. 실행하기 전에 `myFunction(2)`의 결과는 무엇입니까?

```{r}
a <- 4

myFunction(2)
```

그리고 이제 `a`의 값은 무엇입니까?

```{r}
a
```

## `debugonce()`

함수 내에서 `a`의 값을 어떻게 "볼" 수 있습니까?

```{r, eval=FALSE}
debugonce(myFunction)
myFunction(2)
```

이것을 실행하면 이상한 일이 발생합니다(사실 이것은 지극히 정상이지만 이전에는 본 적이 없을 수도 있습니다...).

이제 환경을 보십시오. 전역 환경 대신 함수 `myFunction()`의 환경을 보고 있음을 알 수 있습니다. `x`의 값은 2입니다.

콘솔에는 이제 "다음", "계속" 및 "중지"와 기타 버튼이 표시됩니다. "{ }" 안으로 들어가는 화살표는 R이 다음 함수로 단계별로 진행하기를 원한다는 의미입니다. 선이 있는 화살표는 R이 나머지 함수를 완료하기를 원한다는 의미입니다. 콘솔 프롬프트에도 "Browse[2]"라고 표시됩니다.

RStudio는 또한 별도의 창에서 함수 `myFunction` 코드를 열었고 함수에서 현재 위치를 대략적으로 보여주는 작은 녹색 화살표가 있습니다.
![사용자가 "myFunction"이라는 함수에서 \`debugonce\`를 실행할 때 나타나는 RStudio IDE 창 표시.](img/MiniProject10_debugonce.PNG)

여기서 할 수 있는 일은 함수에서 개별 줄을 실행하고 명령을 제출하고 함수 환경에서 새 객체를 만들거나 값을 바꾸는 것입니다.
함수의 각 줄을 단계별로 실행하면 함수 환경 내에서 `a`에 할당된 값이 3임을 알 수 있습니다. 함수의 각 줄을 단계별로 실행하면서 함수와 관련된 환경에서 새 객체가 정의되고 사용되는 것을 볼 수 있습니다.

RStudio의 환경 탭 내에서 함수 환경 `myFunction()`과 `전역 환경` 사이를 전환하여 함수 내부와 외부에서 `a`가 어떻게 다른지, ***그리고*** `a`가 두 곳에 정의되어 있는지 확인할 수 있습니다...

## 인셉션 - 토끼굴 아래로

함수를 호출하는 함수가 있는 경우 디버그 모드에 무엇이 표시됩니까? `myFunction`의 결과를 가져와서 결과를 제곱하는 새 함수를 정의해 보겠습니다.

```{r}
myFunction_add3_and_squareit <- function(x){
  y <- myFunction(x)
  y*y
}
```

다음 코드를 실행할 때 콘솔에서 ***먼저*** `debugonce(myFunction_add3_and_squareit)`를 지정하는 것을 잊지 마십시오. 그렇지 않으면 코드가 끝까지 실행됩니다...

```{r}
myFunction_add3_and_squareit(4)
```

`myFunction_add3_and_squareit` 함수 호출에서 `myFunction`으로 "단계별로 들어가려면" 콘솔의 디버그 모드에서 버튼을 사용해야 합니다. 이렇게 하면 하위 수준 함수로 더 깊이 들어가 하위 수준에서 발생하는 문제를 해결할 수 있습니다. 함수를 호출하는 함수를 호출하는 함수가 있는 경우 매우 유용합니다. 잊지 마십시오. 깊이 들어갈수록 시간이 훨씬 느리게 갑니다...

### 디버그 모드에 갇히지 마십시오!

디버거가 열리면 콘솔의 특수 "디버그" 모드가 됩니다. 이렇게 하면 함수를 한 줄씩 단계별로 실행하거나 함수가 함수를 호출하는 경우 하위 수준 함수로 단계별로 들어가는 데 도움이 됩니다... 위 이미지에서 그림의 왼쪽 하단에 디버그 콘솔이 어떻게 보이는지 확인할 수 있습니다.

문제를 해결한 후에는 "디버그" 모드에 갇히지 마십시오! 콘솔 보기에서 "중지" 버튼(빨간색 사각형)을 확인하십시오. "중지"를 클릭하여 "디버그" 모드를 종료하고 일반 R 세션으로 돌아갑니다.

이것은 정말 간단한 예이지만 `debugonce()`를 사용한 다음 함수를 호출하는 것은 무엇이 잘못되었는지 알아내는 정말 좋은 방법입니다. R이 모든 함수 입력, 인수 등을 설정한 다음 코드를 테스트하고 최소한의 노력으로 정확히 무엇이 잘못되었는지 알아낼 수 있는 함수 내부에 사용자를 놓기 때문입니다.

## 디버깅에 도움이 되는 코드를 추가합니다.

### 간단하게 유지 - `print()`

디버그 모드로 들어갈 필요 없이 문제를 해결하는 한 가지 쉬운 방법은 코드가 실행될 때 객체를 콘솔에 인쇄하는 `print()` 문을 추가하는 것입니다. 이렇게 하면 객체의 내용을 보고 의미가 있는지 확인할 수 있습니다.

콘솔에 인쇄되는 내용을 식별하기 위해 `paste()`를 사용하는 것이 좋습니다. 즉, `print(paste("a:",a))`

```{r}
myFunction <- function(x){
  print("함수 내:")
  a <- 3
  print(paste("a:",a))
  print(paste("x:",x))
  x + a
  print(paste("x+a:",x+a))
  print("결과:")
  x+a
}

a <- 4

myFunction(2)
```

작업이 끝나면 함수/코드에서 `print()` 문을 삭제하는 것을 잊지 마십시오. 그렇지 않으면 코드가 매우 "수다스러워질" 것입니다...

### `browser()`

작성하는 모든 함수의 코드에 `browser()` 함수를 삽입하여 RStudio의 이 디버깅 환경으로 자동으로 들어갈 수 있습니다. 이는 Shiny 애플리케이션을 개발할 때도 작동합니다. 그러나 `browser()` 함수 호출을 삽입하려면 함수 코드를 변경해야 하며 함수에서 `browser()` 문을 제거할 때까지 함수를 호출할 때마다 디버깅 창이 열립니다. 그러나 여러 수준의 함수나 복잡한 상호 작용이 있는 곳에서 디버깅하려는 특정 상황에서는 유용할 수 있습니다. 브라우저를 삽입하는 곳이면 어디든 R이 실행을 중단하고 위에서 본 디버거로 들어갑니다. 따라서 제대로 작동하는 것으로 알고 있는 부분을 건너뛰고 오류 메시지가 있는 부분 주변에서 디버거를 시작할 수 있습니다...

아래 함수에서는 `Sys.sleep` 함수를 사용하여 15초 동안 대기하여 업스트림 코드 실행을 기다려야 하는 상황을 시뮬레이션하고 있습니다. 그런 다음 `browser` 문이 적용되고 디버거가 열립니다. 디버거가 열리면 실행할 다음 줄은 `Sys.sleep` 함수 호출 다음 줄입니다.

```{r, eval=FALSE}
myFunction_add3_and_squareit <- function(x){
  y <- myFunction(x)
  browser()
  y*y
}


myFunction_add3_and_squareit(4)
```

## 하지만 함수를 사용하지 않는다면 어떻게 해야 합니까?

이러한 디버거 방법은 함수 내에서 무엇이 잘못되었는지 알아내는 데 정말 유용합니다. 함수에 없는 코드, 즉 스크립트를 실행하는 데 문제가 있는 경우에도 비슷한 작업을 수행할 수 있습니다...

RStudio IDE에서 "MiniProject10_breakpoint_script.R" 파일을 엽니다.

편집기 왼쪽, 줄 번호가 있는 곳 왼쪽에 있는 줄 12를 클릭합니다. 이렇게 하면 코드를 일시 중지하고 해당 지점에서 코드를 검사하려는 위치에 빨간색 점 "중단점"이 배치됩니다.

중단점 기능을 사용하려면 코드를 ***소스***해야 합니다. 스크립트의 대화형 실행에서는 사용할 수 없습니다.

## `traceback()`

R에서 오류가 발생하면 R 콘솔에 오류가 표시되는 경우가 있습니다.

```{r, eval=FALSE}
myFunction_add3_and_squareit("a")
```

RStudio는 청크 결과에 "추적 표시"라는 작은 버튼을 추가합니다. (R 콘솔은 그렇지 않습니다). 콘솔에서 `traceback()`을 입력하여 오류가 발생하기 ***전에*** 실행된 단계를 확인할 수 있습니다. 즉, 오류가 발생한 위치입니다. Rmarkdown 청크 출력에서 "추적 표시" 버튼을 클릭하면 동일한 작업이 수행됩니다.

이는 `debugonce()`와 같은 방식으로 도움이 되지 않습니다. 함수 호출 깊숙이 들어가고 디버깅을 위해 모든 객체를 가져가는 것이 문제를 이해(및 수정!)하는 더 좋은 방법이기 때문입니다. 그러나 오류가 발생한 지점을 ***빠르게*** 파악하는 방법입니다.

### `recover()` 및 `options(error = recover)`

일반적으로 오류가 발생하면 R은 실행을 중지하고 오류 메시지를 인쇄하며 (RStudio IDE를 사용하는 경우) traceback()을 사용하여 문제가 발생한 위치를 확인할 수 있는 옵션을 제공합니다. 그러나 `options(error = recover)`를 지정하면 함수에서 빠져나오는 대신 R이 오류가 발생한 위치에서 정확히 일시 중지되어 *현장에서***문제를 해결할 수 있습니다.** 발생하는 일은 `traceback()` 스택에서 디버깅을 시작할 위치를 선택할 수 있다는 것입니다. RStudio IDE를 사용하는 경우 `debugonce()`에서 본 디버그 모드가 되어 코드를 단계별로 실행하여 문제를 찾을 수 있습니다.

```{r, eval=FALSE}
options(error = recover)
myFunction_add3_and_squareit("a")
```

## 도전 과제

아래 `adsl_counts` 함수의 오류 ***소스***는 어디에 있습니까?

```{r, eval=FALSE}
adsl_counts <- function(dataFile) {

 adsl_saf <- dataFile %>%
    filter(SAFFL == "Y")

  Big_N_cnt <-  adsl_saf %>%
    group_by( TRT01AN, TRT01A  ) %>%
    summarise(N = n())

  small_n_cnt <- adsl_saf %>%
    group_by( TRT01AN, TRT01A,  SEX ) %>%
    summarise(name = "n")

  adsl_mrg_cnt <- small_n_cnt %>%
    left_join(Big_N_cnt, by = c("TRT01AN","TRT01A")) %>%
    mutate(perc = round((n/N)*100, digits=1)) %>%
    mutate(perc_char = format(perc, nsmall=1)) %>%
    mutate(npct = paste(n,
                        paste0( "(", perc_char, ")" )
                        )
           ) %>%
    mutate(SEX = recode(SEX,
                        "M" = "Male",
                        "F" = "Female")) %>%
    ungroup() %>%
    select(TRT01A, SEX, npct) %>%
    pivot_wider(names_from = TRT01A, values_from = npct)

  return(adsl_mrg_cnt)
}

library(rio)
library(tidyverse)

inFile <- "https://github.com/phuse-org/phuse-scripts/raw/master/data/adam/cdisc/adsl.xpt"

adsl <- import(inFile)

adsl_counts(dataFile = adsl)
```

## 추가 학점

위 코드를 수정하려면 어떻게 해야 합니까?
