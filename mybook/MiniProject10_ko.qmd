---
title: "디버깅"
author: "Mike K Smith"
date: "2023/3/9"
output: html_document
---

```{
r setup, include=FALSE}
knitr::opts_chunk_set(echo = TRUE)
```

## 디버깅 전략

1.  껐다가 다시 켜기 - 환경 지우기

2.  환경 이해 - 전역 및 지역

    1.  환경에서 사물 보기

3.  `debugonce()` , `browser()` 및 RStudio IDE 중단점.

4.  `traceback()`, `options(error = recover)`,

막히면 이 비디오를 검토하십시오:\
<https://www.youtube.com/watch?v=vgYS-F8opgE>

## 깨끗한 환경은 좋은 것입니다

시간이 지남에 따라 R의 STUFF 컬렉션이 늘어납니다. 문제는 "봄 청소"를 하고 정리하지 않으면 결국 R의 객체 컬렉션에 있는 무언가가 현재 작업에 문제를 일으킬 것이라는 것입니다... 오늘 데이터와 생성한 벡터로만 작업하고 있다고 ***생각***할 수 있지만, 무언가 잘못되면 이전 세션에 존재했던 동일한 이름의 해당 객체 버전을 선택하고 있을 수 있습니다. 이는 다소 위험합니다.

R 세션을 봄 청소하는 가장 쉬운 방법은 환경을 정리하고 R을 다시 시작하는 것입니다.

![R 전역 환경에 "adsl"이라는 데이터, "ALTmax" 및 "ALTmin"이라는 벡터, "uniqueVal"이라는 함수 등 4개의 객체가 있습니다.](img/MiniProject10_Environment.png)

!["빗자루" 아이콘을 클릭하면 나타나는 팝업 대화 상자가 있는 R 전역 환경](img/MiniProject10_CleaningEnvironment.png)

이렇게 하면 환경이 정리되고 "새로" 시작됩니다. 이 작업을 수행하기 전에 보관해야 할 모든 것을 저장하는 것을 잊지 마십시오!!

재현성을 위해 R을 시작하거나 스크립트를 "처음부터 끝까지" 실행하여 출력을 생성할 때마다 "깨끗한" 환경으로 시작하는 것이 좋습니다. 이렇게 하면 스크립트를 실행하는 데 필요한 모든 것이 그 안에 포함되어 있고 실행하기 위해 환경에 객체가 있는 것에 의존하지 않는다는 것을 보장할 수 있습니다.

R 세션을 시작할 때 이 "깨끗한 페이지"로 시작하는 것을 좋아합니다. RStudio IDE의 "전역 옵션"의 일반 탭으로 이동하면 R을 시작할 때 기존 작업 공간(환경)을 다시 로드하지 않고 종료 시 작업 공간을 저장할지 묻지 않는 옵션이 있습니다. 정말 깨끗하고 깔끔하게(그리고 재현 가능하게) 하려면 "복원" 옵션을 선택 취소하고 "저장" 옵션에 대해 "안 함"을 선택해야 합니다. 이렇게 하면 모든 R 세션이 시작할 때 완전히 깨끗해집니다. 매번.

![작업 공간에서 객체를 저장하거나 복원하지 않도록 하는 전역 옵션(RStudio IDE)](img/MiniProject10_GlobalOptions.png)

## 껐다가 다시 켜기

환경을 지우는 "빗자루" 버튼은 많은 좋은 일을 하지만 실제로 ***모든 것***을 지우지는 않습니다. 제거되지 않는 몇 가지 사항:

-   `library( )` 호출

-   R `options( )`

-   시스템 환경 설정, 즉 `Sys.setenv( )`

-   `attach( )`를 사용하여 데이터셋 연결

코드가 재현 가능한지 확인하려면 사용하는 모든 라이브러리가 `library()`를 사용하여 참조/호출되는지 확인해야 합니다. 이는 일반적으로 스크립트 상단에서 수행되므로 다른 사람들이 필요한 라이브러리가 설치되어 있는지 확인할 수 있습니다.

스크립트가 재현 가능한지 ***확인***하는 방법은 R을 다시 시작하는 것입니다. RStudio IDE에서는 "세션" 메뉴에서 또는 바로 가기 키 CTRL+SHIFT+F10을 사용하여 이 작업을 수행할 수 있습니다.

![RStudio 세션 메뉴 또는 바로 가기 키 CTRL+SHIFT+F10에서 R 다시 시작](img/MiniProject10_Restart_R.png)

R을 다시 시작하라는 이 조언은 패키지를 설치하기 전(그리고 후!)에도 특히 사실입니다. R 세션 중간에 패키지를 설치하는 것은 고속도로를 달리는 버스의 타이어를 교체하는 것과 같습니다...

R이 "이상하게" 작동하는 경우 세션을 다시 시작하고 다시 시도하는 것이 좋습니다...

## 환경 이해

전역 환경(R에서 "환경"으로 표시된 패널에서 볼 수 있는 객체 모음)은 R 스크립트 및 R 코드에서 보고 사용할 수 있는 항목 모음입니다. 그러나 다른 환경이 존재하거나 생성될 수 있습니다. 이것이 일반적으로 발생하는 한 곳은 함수 내부입니다. 함수에는 자체 환경이 있습니다. 따라서 함수 호출 내에서 만드는 객체(벡터, 데이터)는 함수의 범위 내에서만 정의됩니다.

함수를 작성하고 실행하면 새 객체를 정의하고 사용할 수 있는 ***실행 환경***이 생성됩니다. 그러나 함수가 완료되면 이러한 모든 객체는 삭제됩니다. 이러한 객체의 목적은 ***오직*** 함수에서 다시 전달될 최종 결과를 만드는 것입니다.

-   ***일반적으로 함수에서 최종 결과 객체만 전달해야 합니다. 함수에서 만든 객체를 전역 환경에 넣지 마십시오.***

-   ***함수 인수을 통해 전달되지 않는 한 함수 내에서 전역 환경 객체를 참조하는 것은 일반적으로 나쁜 습관입니다.***

-   ***함수를 호출할 때 환경에 특정 항목이 있다고 가정해서는 안 됩니다.***

-   ***함수 내에서 옵션을 변경하거나 작업 디렉토리를 설정하는 것은 일반적으로 나쁜 습관입니다.***

이를 설명하기 위해 정말 간단한 함수를 만들어 보겠습니다. 시작하기 전에 빗자루 버튼을 사용하여 환경을 지우거나 R을 다시 시작했는지 확인하십시오. 실행하기 전에 `myFunction(2)`의 결과는 무엇입니까?

```{
r}
myFunction <- function(x){
  a <- 3
  x + a
}

myFunction(2)
```

이제 이 코드를 시도해 보십시오. 실행하기 전에 `myFunction(2)`의 결과는 무엇입니까?

```{
r}
a <- 4

myFunction(2)
```

그리고 이제 `a`의 값은 무엇입니까?

```{
r}
a
```

## `debugonce()`

함수 내에서 `a`의 값을 어떻게 "볼" 수 있습니까?

```{
r, eval=FALSE}
debugonce(myFunction)
myFunction(2)
```

이것을 실행하면 이상한 일이 발생합니다(실제로는 완벽하게 정상이지만 이전에 본 적이 없을 수도 있습니다...).

이제 환경을 보십시오. 전역 환경 대신 이제 함수 `myFunction()`의 환경을 보고 있음을 알 수 있습니다. `x`의 값은 2입니다.

콘솔에는 이제 "다음", "계속" 및 "중지"와 일부 다른 버튼을 보여주는 추가 버튼이 있습니다. "{ } 안으로 화살표"는 R이 다음 함수로 앞으로 나아가기를 원한다는 것을 의미합니다. "선이 있는 화살표"는 R이 함수의 나머지 부분을 완료하기를 원한다는 것을 의미합니다. 콘솔 프롬프트에는 이제 "Browse[2]"도 표시됩니다.

RStudio는 또한 별도의 창에서 함수 `myFunction` 코드를 열었고 함수에서 대략 어디에 있는지 보여주는 작은 녹색 화살표가 있습니다.\
![사용자가 "myFunction"이라는 함수에서 `debugonce`를 실행할 때 나타나는 RStudio IDE 창을 보여줍니다.](img/MiniProject10_debugonce.png)

여기서 할 수 있는 일은 함수의 개별 줄을 실행하고, 명령을 제출하고, 함수 환경에서 새 객체를 만들거나 값을 바꾸는 것입니다.\
함수의 각 줄을 단계별로 실행하면 함수 환경 내에서 `a`에 할당된 값이 3임을 알 수 있습니다. 함수의 각 줄을 단계별로 실행하면서 함수와 관련된 환경에서 새 객체가 정의되고 사용되는 것을 볼 수 있습니다.

RStudio의 환경 탭 내에서 함수 환경 `myFunction()`과 `전역 환경` 사이를 전환하여 함수 내부와 외부에서 `a`가 어떻게 다른지, ***그리고*** `a`가 두 곳에 정의되어 있는지 확인할 수 있습니다...

## 인셉션 - 토끼굴 속으로

함수를 호출하는 함수가 있는 경우 디버그 모드는 무엇을 보여줍니까? `myFunction`의 결과를 가져와 결과를 제곱하는 새 함수를 정의해 보겠습니다.

```{
r}
myFunction_add3_and_squareit <- function(x){
  y <- myFunction(x)
  y*y
}
```

다음 코드를 실행할 때 콘솔에서 ***먼저*** `debugonce(myFunction_add3_and_squareit)`를 지정하는 것을 잊지 마십시오. 그렇지 않으면 코드가 끝까지 실행됩니다...

```{
r}
myFunction_add3_and_squareit(4)
```

`myFunction_add3_and_squareit` 함수 호출에서 `myFunction`으로 "들어가려면" 콘솔의 디버그 모드에서 버튼을 사용해야 합니다. 이렇게 하면 하위 수준 함수로 더 깊이 들어가 하위 수준에서 무슨 일이 일어나고 있는지 해결할 수 있습니다. 함수를 호출하는 함수를 호출하는 함수가 있는 경우 매우 유용합니다. 잊지 마세요: 더 깊이 들어갈수록 시간은 훨씬 더 느리게 흐릅니다...

### 디버그 모드에 갇히지 마십시오!

디버거가 열리면 콘솔의 특수 "디버그" 모드에 있게 됩니다. 이렇게 하면 함수를 한 줄씩 단계별로 실행하거나 함수가 함수를 호출하는 경우 하위 수준 함수로 들어갈 수 있습니다... 위 이미지에서 그림의 왼쪽 하단에 디버그 콘솔이 어떻게 생겼는지 볼 수 있습니다.

문제를 해결한 후에는 "디버그" 모드에 갇히지 마십시오! 콘솔 보기에서 "중지" 버튼(빨간색 사각형)을 확인하십시오. "중지"를 클릭하여 "디버그" 모드를 종료하고 일반 R 세션으로 돌아갑니다.

이것은 정말 간단한 예이지만 `debugonce()`를 사용한 다음 함수를 호출하는 것은 R이 모든 함수 입력, 인수 등을 설정한 다음 코드 테스트, 문제가 무엇인지 정확히 파악하는 데 최소한의 번거로움으로 함수 내부에 놓아주기 때문에 무엇이 잘못되었는지 알아내는 정말 좋은 방법입니다.

## 디버깅에 도움이 되도록 코드에 항목 추가:

### 간단하게 유지 - `print()`

디버그 모드로 들어갈 필요 없이 문제를 해결하는 한 가지 쉬운 방법은 코드가 실행될 때 콘솔에 객체를 인쇄하기 위해 `print()` 문을 추가하는 것입니다. 이렇게 하면 객체의 내용을 보고 의미가 있는지 확인할 수 있습니다.

콘솔에 인쇄되는 내용을 식별하기 위해 `paste()`를 사용하는 것이 좋습니다. 즉, `print(paste("a:",a))`

```{
r}
myFunction <- function(x){
  print("함수 내:")
  a <- 3
  print(paste("a:",a))
  print(paste("x:",x))
  x + a
  print(paste("x+a:",x+a))
  print("결과:")
  x+a
}

a <- 4

myFunction(2)
```

완료되면 함수/코드에서 `print()` 문을 삭제하는 것을 잊지 마십시오. 그렇지 않으면 코드가 매우 "수다스러워"질 것입니다...

### `browser()`

작성하는 모든 함수의 코드에 `browser()` 함수를 삽입하여 RStudio에서 이 디버깅 환경으로 자동으로 들어갈 수 있습니다. 이것은 Shiny 응용 프로그램을 개발할 때도 작동합니다. 그러나 `browser()` 함수 호출을 삽입하려면 함수 코드를 변경해야 하며, 함수에서 `browser()` 문을 제거할 때까지 함수를 호출할 때마다 디버깅 창이 열립니다. 그러나 여러 수준의 함수나 복잡한 상호 작용이 있는 곳에서 디버깅을 시도하는 특정 상황에서는 유용할 수 있습니다. 브라우저를 삽입하는 곳마다 R이 실행을 중단하고 위에서 본 디버거로 들어갑니다. 따라서 작동하는 것으로 알고 있는 부분을 건너뛰고 오류 메시지가 있는 곳 주변에서 디버거를 입력할 수 있습니다...

아래 함수에서는 `Sys.sleep` 함수를 사용하여 15초 동안 기다려 업스트림 코드 실행을 기다려야 하는 상황을 시뮬레이션하고 있습니다. 그런 다음 `browser` 문이 적용되고 디버거를 엽니다. 디버거가 열리면 실행할 다음 줄은 `Sys.sleep` 함수 호출 다음 줄이라는 점에 유의하십시오.

```{
r, eval=FALSE}
myFunction_add3_and_squareit <- function(x){
  y <- myFunction(x)
  browser()
  y*y
}


myFunction_add3_and_squareit(4)
```

## 하지만 함수를 사용하지 않는다면?

이러한 디버거 방법은 함수 내에서 무엇이 잘못되었는지 밝히는 데 정말 유용합니다. 함수에 없는 코드에 문제가 있는 경우, 즉 스크립트를 실행하는 경우에도 비슷한 작업을 수행할 수 있습니다...

RStudio IDE에서 "MiniProject10_breakpoint_script.R" 파일을 엽니다.

편집기의 왼쪽, 줄 번호가 있는 곳 왼쪽에 있는 12번 줄을 클릭합니다. 이렇게 하면 코드를 일시 중지하고 해당 지점에서 코드를 검사하려는 곳에 빨간색 점 "중단점"이 배치됩니다.

중단점 기능을 사용하려면 코드를 ***소스***해야 합니다. 스크립트의 대화형 실행에서는 사용할 수 없습니다.

## `traceback()`

R에서 오류가 발생하면 R 콘솔에 오류가 표시되는 경우가 있습니다.

```{
r, eval=FALSE}
myFunction_add3_and_squareit("a")
```

RStudio는 청크 결과에 "추적 표시"라는 작은 버튼을 추가합니다. (R 콘솔은 그렇지 않습니다). 콘솔에서 `traceback()`을 입력하여 오류가 발생하기 ***전에*** 실행된 단계를 볼 수 있습니다. 즉, 오류가 발생한 위치입니다. Rmarkdown 청크 출력에서 "추적 표시" 버튼을 클릭하면 동일한 작업을 수행합니다.

이것은 `debugonce()`와 같은 방식으로 도움이 되지 않습니다. 왜냐하면 함수 호출 깊숙이 들어가고 디버깅을 위해 모든 객체를 가져가는 것이 문제를 이해하고 수정하는 더 좋은 방법이기 때문입니다. 그러나 오류가 발생한 지점을 파악하는 ***빠른*** 방법입니다.

### `recover()` 및 `options(error = recover)`

일반적으로 오류가 발생하면 R은 실행을 중지하고 오류 메시지를 인쇄하며 (RStudio IDE에 있는 경우) traceback()을 사용하여 문제가 발생한 위치를 볼 수 있는 옵션을 제공합니다. 그러나 `options(error = recover)`를 지정하면 함수에서 빠져나오는 대신 R은 오류가 발생한 위치에서 정확히 일시 중지하여 ***현장에서*** 문제를 해결할 수 있습니다. 발생하는 일은 `traceback()` 스택에서 디버깅을 시작할 위치를 선택할 수 있는 옵션이 있다는 것입니다. RStudio IDE를 사용하는 경우 `debugonce()`에서 본 디버그 모드에 있으며 코드를 단계별로 실행하여 문제를 찾을 수 있습니다.

```{
r, eval=FALSE}
options(error = recover)
myFunction_add3_and_squareit("a")
```

## 챌린지

아래 `adsl_counts` 함수에서 오류의 ***소스***는 어디에 있습니까?

```{
r, eval=FALSE}
adsl_counts <- function(dataFile) {
  
 adsl_saf <- dataFile %>%
    filter(SAFFL == "Y")
  
  Big_N_cnt <-  adsl_saf %>%
    group_by( TRT01AN, TRT01A  ) %>%
    summarise(N = n())

  small_n_cnt <- adsl_saf %>%
    group_by( TRT01AN, TRT01A,  SEX ) %>%
    summarise(name = "n")

  adsl_mrg_cnt <- small_n_cnt %>%
    left_join(Big_N_cnt, by = c("TRT01AN","TRT01A")) %>%
    mutate(perc = round((n/N)*100, digits=1)) %>%
    mutate(perc_char = format(perc, nsmall=1)) %>%
    mutate(npct = paste(n, 
                        paste0( "(", perc_char, ")" ) 
                        ) 
           ) %>%
    mutate(SEX = recode(SEX, 
                        "M" = "Male",
                        "F" = "Female")) %>%
    ungroup() %>%
    select(TRT01A, SEX, npct) %>%
    pivot_wider(names_from = TRT01A, values_from = npct) 
  
  return(adsl_mrg_cnt)
}

library(rio)
library(tidyverse)

inFile <- "./data/adsl.xpt"

adsl <- import(inFile)

adsl_counts(dataFile = adsl)
```

## 추가 학점

위 코드를 수정하려면 무엇을 해야 합니까?
