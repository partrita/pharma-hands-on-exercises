---
title: "데이터셋 읽기 및 탐색"
author: "Mike K Smith"
date: "2023/08/02"
output: html_document
---

# 데이터셋 읽기 및 탐색

## 목표:

- ADSL xpt 데이터셋 읽기
- 유효성 모집단(Efficacy Population)에 대한 부분집합 만들기
- 데이터 정렬하기
- 인구통계 목록 보기

## 이 문서 사용법:

이 문서에서는 코드 청크(일반적으로 밝은 회색 배경)와 텍스트를 볼 수 있습니다. 이것은 "Rmarkdown" 문서의 예입니다. 문서 내에서 코드를 작성하고 실행할 수 있으며 결과는 각 코드 청크 아래에 표시됩니다. 텍스트에 작성된 지침에 따라 코드 청크를 수정하고 실행하여 지시된 대로 출력을 생성해야 합니다.

## 데이터 소스

이 프로젝트에서는 익명화된 CDISC 데이터셋을 사용하며, 여기에서 찾을 수 있습니다: <https://github.com/phuse-org/phuse-scripts/tree/master/data/adam/cdisc>

## R 객체 및 함수

R 내에서는 일반적으로 데이터, 벡터, 리스트 등 다양한 유형의 객체를 사용한 다음 함수를 적용합니다. 함수는 `<함수_이름>(<인수1>=   , <인수2> = )` 구조를 가집니다. 함수를 사용할 때 인수 이름을 반드시 사용할 필요는 없으며, 대신 위치에 따라 암시적으로 인수를 참조할 수 있습니다. 예를 들어 `myFunction(foo, 1, "bar")`는 R 객체 `foo`를 인수 1의 값으로 전달하고, 인수 2는 값 `1`을, 인수 3은 문자 값 `"bar"`를 갖습니다. R을 배우는 동안에는 함수에 하나의 인수만 있는 경우를 제외하고는 함수에서 인수를 명시적으로 이름 짓고 사용하는 것이 좋습니다. RStudio IDE의 탭 완성 기능을 사용하여 함수 호출 인수를 완성할 수 있습니다. 함수의 인수를 보려면 콘솔에 `?<함수이름>`을 입력하십시오.

## 미니 프로젝트 시작

1. 다음 단계에서는 `tidyverse`, `rio`, `skimr`, `htmlTable` 패키지를 로드합니다. 패키지를 사용하기 전에 해당 패키지의 함수와 내용을 로드해야 하며, 프로그램이나 스크립트의 시작 부분에서 이 작업을 수행하는 것이 가장 좋습니다. 코드 청크 오른쪽의 녹색 화살표를 클릭하여 아래 청크를 실행하십시오.

```{r setup}
library(tidyverse)
library(rio)
library(skimr)
library(htmlTable)
```

2. R에서 데이터를 읽어오는 방법과 패키지는 여러 가지가 있습니다. 예를 들어, `haven` 패키지에는 `read_xpt()`라는 함수가 있어 `*.xpt` 파일에서 R 데이터 객체를 만들 수 있습니다. `readr` 패키지는 쉼표로 구분된 값(CSV) 및 탭으로 구분된 값(TSV)과 같은 구분된 파일에서 사각형 데이터를 빠르고 쉽게 읽을 수 있는 방법을 제공합니다. `readxl` 패키지를 사용하면 Excel에서 R로 데이터를 쉽게 가져올 수 있습니다. 패키지에 관계없이 데이터를 읽어오는 함수는 첫 번째 인수로 데이터 경로를 사용하는 경향이 있지만, 새 패키지나 함수를 사용하기 전에 항상 설명서를 읽는 것이 중요합니다.

우리 미니 프로젝트에서는 `rio` 패키지를 사용하여 데이터를 읽을 것입니다. `rio`는 가져오기 및 내보내기를 위해 다양한 파일 형식을 지원하며 간소화된 데이터 가져오기를 제공합니다. 특히 `rio`는 파일 이름의 확장자를 사용하여 파일 종류를 결정하므로 `rio`를 사용하여 데이터 파일을 읽기 위해 기억해야 할 유일한 함수는 `import()`입니다.

GitHub 위치(`https://github.com/phuse-org/phuse-scripts/raw/master/data/adam/cdisc/adsl.xpt`)에서 adsl 데이터를 읽어와 할당 연산자 `<-`를 사용하여 R의 객체에 할당합니다. URL 위치가 `" "`로 묶인 문자열인지 확인하십시오. 아래 코드의 `""` 인수 안에 다운로드 경로 위치를 붙여넣은 다음 녹색 화살표를 사용하여 청크를 실행하십시오.

```{r read_adsl_data}
adsl <- import(file = "./data/adsl.xpt")
```

3. R 객체 `adsl`의 처음 10개 행을 보려면 데이터셋 이름을 입력하기만 하면 됩니다. 아래 청크에 `adsl`을 입력하고 녹색 화살표를 사용하여 실행하십시오:

```{r view_adsl_object}
head(adsl)
```

`adsl` 데이터 객체는 254개의 행과 48개의 열을 가지고 있습니다.

4. 다음으로, R 함수 `sapply`를 사용하여 데이터셋의 각 열 유형을 확인합니다. 이를 통해 열이 문자, 숫자, 정수, 배정밀도, 팩터 등인지 알 수 있습니다. `class` 함수는 R 객체의 유형을 알려줍니다.

`sapply` 함수는 데이터의 각 열에 동일한 함수 `class`를 적용하고 데이터 유형을 벡터로 반환합니다.

```{r view_adsl_data_types}
sapply(X = adsl, FUN = class)
```

5. 개별 변수의 유형(또는 `class`)을 확인(또는 테스트)하려면 `is.numeric`, `is.character` 등의 함수를 사용할 수 있습니다. 데이터 객체의 개별 열을 참조하려면 `<객체>$<변수>` 구문을 사용할 수 있습니다.

[**R은 대소문자를 구분합니다! R 객체, 변수 또는 데이터셋의 이름을 입력할 때 대소문자가 표시된 것과 일치하는지 확인하십시오.**]{.smallcaps} 따라서 "AGE"는 "age" 또는 "Age"와 같지 않습니다. 아래 변수 이름은 대문자로 표시됩니다.

`AGE` 변수가 숫자인지, `RACE`가 문자인지 확인해 보겠습니다.

```{r check_variable_types}
is.numeric(adsl$AGE)
is.character(adsl$RACE)
```

6. R 작업을 도와주는 *많은* R 패키지가 있습니다. `skimr` 패키지는 데이터셋에 대한 유용한 요약 정보(행, 열 수, 결측 데이터, 열 유형, 데이터 열의 값 분포)를 신속하게 표시하는 패키지 중 하나입니다.

```{r skimr}
skim(data = adsl)
```

> 참고: 출력의 일부로 경고 메시지가 표시될 수 있습니다.

일부 열에 결측값이 있는 경우 이러한 경고 메시지를 사용하여 데이터 형식이 올바른지, 열이 올바르게 구문 분석되었는지 확인할 수 있습니다. 예를 들어 코딩된 값이 0, 1인 열은 숫자로 읽힐 수 있습니다. 이대로 두시겠습니까, 아니면 팩터로 해석하시겠습니까?

7. 이제 유효성 분석 모집단에 대한 새 데이터 객체 `adsl_eff`를 만듭니다. 변수 `EFFFL`의 값이 `Y`인 `adsl` 데이터 객체를 필터링해야 합니다. R에서 동등성을 테스트하려면 이중 등호 `==`를 사용해야 합니다. 아래 `filter` 함수의 첫 번째 인수(`.data=`)로 `adsl` 객체를 입력하십시오.

```{r create_adsl_eff}
adsl_eff <- filter(.data = adsl, EFFFL == 'Y')
head(adsl_eff)
```

`EFFFL == 'Y'`인 데이터를 필터링한 후 이제 234개의 행과 48개의 열이 있습니다.

다시 말하지만, R은 대소문자를 구분합니다. SAS 데이터셋의 대부분의 변수 이름은 대문자이므로 변수 이름이 `Efffl` 등이 아닌 `EFFFL`인지 확인해야 합니다. 또한 값이 문자이므로 동등한 값의 대소문자가 예상 결과(예: `y` 또는 `Yes`가 아닌 `Y`)와 일치하고 따옴표 `" "`로 묶여 있는지 확인해야 합니다.

8. `adsl_eff` 데이터 객체를 `USUBJID` 변수로 정렬합니다. 첫 번째 인수 뒤에 정렬하려는 변수를 입력하십시오.

```{r arrange_adsl_eff}
sort_adsl_eff <- arrange(.data = adsl_eff, USUBJID)
head(sort_adsl_eff) # 정렬된 데이터 프레임을 표시합니다.
```

R의 `tidyverse` 패키지에는 여러 단계를 결합할 수 있는 파이프 연산자 `%>%`가 있습니다. 파이프는 이전 단계의 출력 객체를 다음 함수의 첫 번째 인수에 사용할 값으로 전달합니다. 따라서 이전 단계를 다음 데이터 파이프라인으로 결합합니다.

```{r using_pipe}
sort_adsl_eff <- adsl %>%
  filter(EFFFL == "Y") %>%
  arrange(USUBJID)
```

`%>%` 연산자를 사용할 때 이것을 "...그런 다음..."으로 읽습니다. 따라서 위 파이프라인은 "(**adsl_eff**라는 객체 생성)은 (**adsl** 객체로 시작하여) **할당됨** *...그런 다음...* **필터링** (`EFFFL`이 "Y"인 경우) *...그런 다음...* **정렬** (`USUBJID` 기준)." 파이프 연산자를 사용하면 중간 객체를 R에서 명명된 객체로 유지할 가치가 없는 단계를 결합할 수 있습니다. 파이프 연산자를 사용할 때 더 이상 다음 함수의 `.data =` 인수를 명시적으로 사용하지 않는다는 점에 유의하십시오. 이는 `%>%`가 기본적으로 이전 객체를 첫 번째 인수의 값으로 전달하기 때문입니다.

9. 다음을 시도하여 `EFFFL=='Y'`인 관측치가 234개임을 보여주는 `adsl_eff`의 `skim` 요약을 확인하십시오.

```{r skim_adsl_eff}
skim(adsl_eff)
```

10. `adsl_eff` 데이터를 `TRT01A`, `USUBJID` 변수로 정렬하고 새 데이터셋 `adsl_eff_srt`를 만듭니다. 이전 코드(힌트: `arrange( )`)를 사용하여 데이터를 정렬할 수 있습니다.

```{r sort_adsl_eff}
adsl_eff_srt <- arrange(.data = adsl_eff, TRT01A, USUBJID)
head(adsl_eff_srt) # 정렬된 데이터 프레임을 표시합니다.
```

11. `select` 함수는 데이터 객체의 지정된 열만 선택합니다. `adsl_saf_srt` 데이터 객체에서 다음 변수만 선택하십시오: `USUBJID, AGE, AGEU, SEX, RACE, ETHNIC, TRT01A`. 이 변수 목록을 복사하여 `select` 문에 붙여넣으십시오.

```{r adsl_saf_srt_select}
adsl_eff_srt <- adsl_eff_srt %>%
  select(USUBJID, AGE, AGEU, SEX, RACE, ETHNIC, TRT01A)
head(adsl_eff_srt)
```

이제 `adsl_eff_srt` 데이터 객체는 여전히 234개의 행을 가지고 있지만 열은 7개뿐입니다.

12. 일반적으로 인구통계 목록은 데이터셋의 변수 이름을 직접 사용하지 않습니다. 따라서 열 이름을 변경하는 단계를 추가합니다. `names()` 함수는 문자/이름 벡터를 전달하여 지정된 객체의 이름을 할당합니다. 컬렉션 함수 `c( )`와 쉼표로 구분된 이름 목록을 사용하여 벡터를 만듭니다. 아래 코드를 사용하여 `adsl_saf_srt` 함수의 변수 이름을 `"Subject ID","Age","AgeUnits","Sex","Race","Ethnicity","Treatment"`로 변경하십시오.

```{r rename_adsl_eff_srt}
names(x = adsl_eff_srt) <- c("Subject ID", "Age", "AgeUnits", "Sex", "Race", "Ethnicity", "Treatment")
# 새 이름을 확인합니다.
head(adsl_eff_srt)
```

13. 이제 데이터 목록을 생성할 수 있습니다. R에는 테이블을 표시하거나 목록을 인쇄할 수 있는 여러 패키지가 있습니다. 이와 같은 Rmarkdown 문서에서는 출력을 인쇄하기만 하면 데이터의 멋진 HTML 표현이 만들어집니다. 아래에 데이터 객체 이름을 추가하여 Rmarkdown 문서에 표시하십시오.

```{r}
head(adsl_eff_srt)
```

그러나 나중에 사용하기 위해 이 출력을 저장하려면 이러한 패키지 중 하나를 사용하여 데이터 목록이 포함된 출력 파일을 만들어야 합니다. 각 테이블 패키지에는 장단점이 있지만 지금은 `htmlTable` 패키지를 사용하여 HTML 목록을 표시해 보겠습니다. 아래에 데이터 객체 이름을 추가하여 `htmlTable` 출력을 표시하십시오. 여기의 추가 인수는 테이블 형식이 보기 좋게 만들어지도록 합니다. 이는 이 첫 번째 프로젝트의 범위를 벗어납니다. `align = "l"` 인수를 변경하고 `align = "c"` 또는 `align = "r"` 옵션을 시도하여 열 내용을 각각 왼쪽, 가운데 또는 오른쪽으로 정렬해 보십시오.

```{r}
#| eval: false
htmlTable(x =  adsl_eff_srt,
          align = "l", # 내용을 왼쪽으로 정렬합니다.
          rnames = FALSE,
          css.cell = "padding-left: .5em; padding-right: .2em;")
```
